name: Send approved PDF to DocuSign (JWT)

on:
  push:
    branches:
      - main
    paths:
      - "docs/*.pdf"
  workflow_dispatch:  # Allow manual trigger
    inputs:
      pdf_file:
        description: 'Specific PDF file to send (e.g., SOP-001.pdf)'
        required: false
        type: string

jobs:
  send_to_docusign:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for diff

      # Setup jq properly instead of apt-get every time
      - name: Setup jq
        uses: dcarbone/install-jq-action@v2

      # Find which PDF(s) changed
      - name: Find target PDF
        id: pdf
        run: |
          set -e

          # Manual trigger with specific file
          if [ -n "${{ github.event.inputs.pdf_file }}" ]; then
            PDF_PATH="docs/${{ github.event.inputs.pdf_file }}"
            if [ -f "$PDF_PATH" ]; then
              echo "Manual trigger: Using $PDF_PATH"
              echo "path=$PDF_PATH" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "Error: Specified file not found: $PDF_PATH"
              exit 1
            fi
          fi

          # Automatic trigger: find changed PDFs
          FILES=$(git diff-tree --no-commit-id --name-only -r "$GITHUB_SHA" | grep "^docs/.*\.pdf$" || true)

          if [ -z "$FILES" ]; then
            echo "‚ÑπÔ∏è No changed PDFs detected in this commit."
            echo "Nothing to send to DocuSign."
            exit 0
          fi

          echo "üìÑ Changed PDFs:"
          echo "$FILES"

          # Use first changed PDF
          FIRST=$(echo "$FILES" | head -n 1)
          echo "‚úì Selected: $FIRST"
          echo "path=$FIRST" >> "$GITHUB_OUTPUT"

      # Generate JWT and get DocuSign access token
      - name: Get DocuSign access token via JWT
        if: steps.pdf.outputs.path != ''
        id: jwt
        env:
          DOCUSIGN_INTEGRATION_KEY: ${{ secrets.DOCUSIGN_INTEGRATION_KEY }}
          DOCUSIGN_USER_ID: ${{ secrets.DOCUSIGN_USER_ID }}
          DOCUSIGN_AUTH_SERVER: ${{ secrets.DOCUSIGN_AUTH_SERVER }}
          DOCUSIGN_PRIVATE_KEY: ${{ secrets.DOCUSIGN_PRIVATE_KEY }}
        run: |
          set -e

          echo "üîê Generating JWT for DocuSign authentication..."

          # Save private key to file (will be cleaned up automatically)
          echo "$DOCUSIGN_PRIVATE_KEY" > private.key
          chmod 600 private.key

          # Token lifetime: 1 hour
          NOW=$(date +%s)
          EXP=$((NOW + 3600))

          # Build JWT components
          HEADER='{"alg":"RS256","typ":"JWT"}'
          PAYLOAD=$(cat <<EOF
{"iss":"$DOCUSIGN_INTEGRATION_KEY","sub":"$DOCUSIGN_USER_ID","aud":"$DOCUSIGN_AUTH_SERVER","scope":"signature impersonation","exp":$EXP}
EOF
          )

          # Base64url encoding function
          b64url() {
            openssl base64 -e -A | tr '+/' '-_' | tr -d '='
          }

          # Encode header and payload
          HEADER_B64=$(printf '%s' "$HEADER" | b64url)
          PAYLOAD_B64=$(printf '%s' "$PAYLOAD" | b64url)
          DATA="$HEADER_B64.$PAYLOAD_B64"

          # Sign with RSA-SHA256
          SIGNATURE=$(printf '%s' "$DATA" \
            | openssl dgst -sha256 -sign private.key \
            | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

          JWT="$DATA.$SIGNATURE"

          echo "üåê Requesting access token from DocuSign..."

          # Request access token
          RESPONSE=$(curl --silent --show-error --fail \
            --request POST \
            --url "https://${DOCUSIGN_AUTH_SERVER}/oauth/token" \
            --header "Content-Type: application/x-www-form-urlencoded" \
            --data "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${JWT}")

          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')

          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
            echo "‚ùå Failed to obtain access token"
            echo "Response: $RESPONSE"
            exit 1
          fi

          echo "‚úì Access token obtained"

          # Mask token in logs and save to output
          echo "::add-mask::$ACCESS_TOKEN"
          echo "token=$ACCESS_TOKEN" >> "$GITHUB_OUTPUT"

          # Cleanup
          rm -f private.key

      # Prepare PDF (save to file instead of GITHUB_OUTPUT to avoid size limits)
      - name: Prepare PDF
        if: steps.pdf.outputs.path != ''
        id: prepare
        run: |
          set -e

          PDF_PATH="${{ steps.pdf.outputs.path }}"

          if [ ! -f "$PDF_PATH" ]; then
            echo "‚ùå Error: PDF file not found: $PDF_PATH"
            exit 1
          fi

          FILENAME=$(basename "$PDF_PATH")
          FILESIZE=$(stat -f%z "$PDF_PATH" 2>/dev/null || stat -c%s "$PDF_PATH" 2>/dev/null)
          FILESIZE_MB=$(echo "scale=2; $FILESIZE / 1048576" | bc)

          echo "üìÑ PDF Details:"
          echo "  Path: $PDF_PATH"
          echo "  Filename: $FILENAME"
          echo "  Size: ${FILESIZE_MB} MB"

          # Encode to base64 and save to file
          echo "üîÑ Encoding PDF to base64..."
          base64 -w0 "$PDF_PATH" > pdf_base64.txt

          # Verify base64 encoding
          B64_SIZE=$(stat -f%z pdf_base64.txt 2>/dev/null || stat -c%s pdf_base64.txt 2>/dev/null)
          echo "  Base64 size: $B64_SIZE bytes"

          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"
          echo "‚úì PDF prepared for DocuSign"

      # Send envelope to DocuSign
      - name: Send envelope to DocuSign
        if: steps.pdf.outputs.path != ''
        env:
          DOCUSIGN_BASE_URI: ${{ secrets.DOCUSIGN_BASE_URI }}
          DOCUSIGN_ACCOUNT_ID: ${{ secrets.DOCUSIGN_ACCOUNT_ID }}
          DOCUSIGN_SIGNER_EMAIL: ${{ secrets.DOCUSIGN_SIGNER_EMAIL }}
          DOCUSIGN_SIGNER_NAME: ${{ secrets.DOCUSIGN_SIGNER_NAME }}
        run: |
          set -e

          ACCESS_TOKEN="${{ steps.jwt.outputs.token }}"
          B64=$(cat pdf_base64.txt)
          FILENAME="${{ steps.prepare.outputs.filename }}"

          if [ -z "$ACCESS_TOKEN" ]; then
            echo "‚ùå No access token available"
            exit 1
          fi

          echo "üì§ Creating envelope in DocuSign..."
          echo "  Document: $FILENAME"
          echo "  Signer: $DOCUSIGN_SIGNER_NAME <$DOCUSIGN_SIGNER_EMAIL>"

          # Build JSON payload using jq for proper escaping
          PAYLOAD=$(jq -n \
            --arg subject "Please sign: $FILENAME" \
            --arg doc_b64 "$B64" \
            --arg doc_name "$FILENAME" \
            --arg signer_email "$DOCUSIGN_SIGNER_EMAIL" \
            --arg signer_name "$DOCUSIGN_SIGNER_NAME" \
            '{
              emailSubject: $subject,
              documents: [{
                documentBase64: $doc_b64,
                name: $doc_name,
                fileExtension: "pdf",
                documentId: "1"
              }],
              recipients: {
                signers: [{
                  email: $signer_email,
                  name: $signer_name,
                  recipientId: "1",
                  routingOrder: "1",
                  tabs: {
                    signHereTabs: [{
                      documentId: "1",
                      pageNumber: "1",
                      xPosition: "100",
                      yPosition: "100"
                    }]
                  }
                }]
              },
              status: "sent"
            }')

          # Send to DocuSign
          RESPONSE=$(curl --silent --show-error --fail \
            --request POST \
            --url "${DOCUSIGN_BASE_URI}/restapi/v2.1/accounts/${DOCUSIGN_ACCOUNT_ID}/envelopes" \
            --header "Authorization: Bearer ${ACCESS_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "$PAYLOAD")

          # Parse response
          ENVELOPE_ID=$(echo "$RESPONSE" | jq -r '.envelopeId')
          STATUS=$(echo "$RESPONSE" | jq -r '.status')

          if [ -z "$ENVELOPE_ID" ] || [ "$ENVELOPE_ID" = "null" ]; then
            echo "‚ùå Failed to create envelope"
            echo "Response: $RESPONSE"
            exit 1
          fi

          echo "‚úÖ Envelope created successfully!"
          echo "  Envelope ID: $ENVELOPE_ID"
          echo "  Status: $STATUS"
          echo ""
          echo "üìß Signature request has been sent to:"
          echo "  ‚Üí $DOCUSIGN_SIGNER_NAME <$DOCUSIGN_SIGNER_EMAIL>"
          echo ""
          echo "üîí Part 11 Compliant Process:"
          echo "  ‚úì Document frozen in PDF format"
          echo "  ‚úì Electronic signature with audit trail"
          echo "  ‚úì Signer authentication via DocuSign"
          echo "  ‚úì Certificate of Completion will be generated"

      - name: Cleanup
        if: always()
        run: |
          rm -f pdf_base64.txt private.key

      - name: Summary
        if: always()
        run: |
          if [ -n "${{ steps.pdf.outputs.path }}" ]; then
            echo "‚úÖ DocuSign workflow completed"
            echo "üìÑ Document: ${{ steps.prepare.outputs.filename }}"
          else
            echo "‚ÑπÔ∏è No PDFs to process"
          fi